""" generate Class_CorresPoint_withNormxxxxxx.txt for the input folder
    The origin Class_CorresPointxxxxxx.txt generated by ZebraPose is not containing the information of correspondence's normal. We generate new class_CorresPoint_withNormxxxxxx.txt from the origin one and save in the same folder.
    Usage: python generate_Class_CorresPoint_withNorm.py [input_folder_path]
    example: python generate_Class_CorresPoint_withNorm.py /home/dataset/zebrapose/data/lmo/models_GT_color/
"""
import os
import sys
import argparse
import numpy as np

import open3d as o3d

def generate_with_norm(path, outpath):
    print(f"read from {path}, write to {outpath}")
    list_3D_points = []
    first_line = None
    with open(path, "r") as f:
        first_line = f.readline()
        for line in f:
            line = line[:-1]
            code, x, y, z= line.split(" ")
            x = float(x)
            y = float(y)
            z = float(z)

            list_3D_points.append(np.array([x,y,z]))
    pcd = o3d.io.read_point_cloud("None")
    pcd.points = o3d.utility.Vector3dVector(np.array(list_3D_points))
    pcd.estimate_normals()
    visualize = False
    if visualize:
        o3d.visualization.draw_geometries([pcd], point_show_normal=True)
    print("-----------------")
    
    assert not os.path.exists(outpath), f"{outpath} exist!"
    with open(outpath, "w") as f:
        f.write(first_line)
        for i, (point, normal) in enumerate(zip(np.asarray(pcd.points), np.asarray(pcd.normals))):
            f.write("{} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f} {:.4f}\n".format(i, point[0], point[1], point[2], normal[0], normal[1], normal[2]))

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('folder', help='path to the input folder')
    parser.add_argument('--output_folder', default=None, help='path to the output folder, default is the same as input folder')
    args = parser.parse_args()
    folder = args.folder
    output_folder = args.output_folder
    if output_folder is None:
        output_folder = folder

    path_list = [filename for filename in os.listdir(folder) if filename.startswith("Class_CorresPoint") and filename.endswith(".txt")]
    path_list.sort(key=lambda x:int(x[-10:-4]))

    for filename in path_list:
        filepath = os.path.join(folder, filename)
        output_filepath = os.path.join(output_folder, filename.replace("CorresPoint", "CorresPoint_withNorm"))
        generate_with_norm(filepath, output_filepath)

